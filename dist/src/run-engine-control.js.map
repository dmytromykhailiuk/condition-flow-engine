{"version":3,"file":"run-engine-control.js","sourceRoot":"","sources":["../../src/run-engine-control.ts"],"names":[],"mappings":";;;AAAA,+DAA8F;AAC9F,+BAAsE;AAQtE,MAAM,gBAAgB,GAAG,CACvB,aAAsC,EACtC,QAA0E,EAC1E,QAA4B,EAC5B,gBAA+B,EAAE,EACjC,EAAE;IACF,MAAM,IAAI,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAEzC,IACE,CAAE,aAAuD,CAAC,IAAI;QAC9D,CAAE,aAAuD,CAAC,EAAE,EAC5D;QACA,QAAQ,CAAC,EAAE,gBAAgB,EAAE,aAAa,CAAC,gBAAgB,EAAE,EAAE,QAAQ,CAAC,CAAC;QACzE,OAAO,IAAA,SAAE,EAAC,EAAE,CAAC,CAAC;KACf;IAED,OAAO,IAAA,SAAE,EAAC,EAAE,CAAC,CAAC,IAAI,CAChB,IAAA,2EAAqD,EAClD,aAAuD,CAAC,IAAI,EAC7D,QAAQ,EACR,aAAa,CACd,EACD,IAAA,2EAAqD,EAClD,aAAuD,CAAC,EAAE,EAC3D,QAAQ,EACR,aAAa,CACd,EACD,IAAA,gBAAS,EAAC,GAAG,EAAE;QACb,QAAQ,CAAC,EAAE,gBAAgB,EAAE,aAAa,CAAC,gBAAgB,EAAE,EAAE,QAAQ,CAAC,CAAC;QAEzE,OAAO,IAAI,CAAC,CAAC,CAAC,IAAA,SAAE,EAAC,EAAE,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,aAAa,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;IAC5F,CAAC,CAAC,CACH,CAAC;AACJ,CAAC,CAAC;AAEK,MAAM,iBAAiB,GAAG,CAC/B,cAAyC,EACzC,QAA0E,EAC1E,QAA4B,EAC5B,gBAA+B,EAAE,EACjC,EAAE,CACF,IAAA,WAAI,EAAC,cAAc,CAAC;KACjB,IAAI,CAAC,IAAA,eAAQ,EAAC,CAAC,aAAa,EAAE,EAAE,CAAC,gBAAgB,CAAI,aAAa,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC,CAAC;KACxG,SAAS,EAAE,CAAC;AARJ,QAAA,iBAAiB,qBAQb","sourcesContent":["import { subscribeOnAllDataAndContinueWhenConditionWillBeValid } from './condition-operators';\nimport { from, mergeMap, ObservableInput, of, switchMap } from 'rxjs';\nimport {\n  ConditionsMap,\n  EngineBackgroundControl,\n  EngineBackgroundControlBase,\n  EngineBackgroundControlWithTransition,\n} from './interfaces';\n\nconst runEngineControl = <T>(\n  engineControl: EngineBackgroundControl,\n  callback: (_: EngineBackgroundControlBase, _2: ObservableInput<T>) => void,\n  context$: ObservableInput<T>,\n  conditionsMap: ConditionsMap = {},\n) => {\n  const once = Boolean(engineControl.once);\n\n  if (\n    !(engineControl as EngineBackgroundControlWithTransition).from &&\n    !(engineControl as EngineBackgroundControlWithTransition).to\n  ) {\n    callback({ runEngineMethods: engineControl.runEngineMethods }, context$);\n    return of({});\n  }\n\n  return of({}).pipe(\n    subscribeOnAllDataAndContinueWhenConditionWillBeValid(\n      (engineControl as EngineBackgroundControlWithTransition).from,\n      context$,\n      conditionsMap,\n    ),\n    subscribeOnAllDataAndContinueWhenConditionWillBeValid(\n      (engineControl as EngineBackgroundControlWithTransition).to,\n      context$,\n      conditionsMap,\n    ),\n    switchMap(() => {\n      callback({ runEngineMethods: engineControl.runEngineMethods }, context$);\n\n      return once ? of({}) : runEngineControl(engineControl, callback, context$, conditionsMap);\n    }),\n  );\n};\n\nexport const runEngineControls = <T>(\n  engineControls: EngineBackgroundControl[],\n  callback: (_: EngineBackgroundControlBase, _2: ObservableInput<T>) => void,\n  context$: ObservableInput<T>,\n  conditionsMap: ConditionsMap = {},\n) =>\n  from(engineControls)\n    .pipe(mergeMap((engineControl) => runEngineControl<T>(engineControl, callback, context$, conditionsMap)))\n    .subscribe();\n"]}